# Progress Log
PRD: git-worktree-nvim
Started: 2026-01-16

## Codebase Patterns
- **Module structure**: Each module returns a table M with public functions
- **Type safety**: LuaCATS annotations in types.lua, @class and @param tags
- **Config pattern**: config.setup() validates and deep extends defaults

---
<!-- Task logs below - APPEND ONLY -->

## Task - setup-1
- Created plugin directory structure: lua/git-worktree/, plugin/
- Implemented lua/git-worktree/init.lua with setup() function that delegates to config
- Implemented lua/git-worktree/config.lua with defaults, validation via vim.validate()
- Implemented lua/git-worktree/types.lua with LuaCATS annotations for Worktree, hooks, options
- Implemented plugin/git-worktree.lua registering :Worktree command
- Verified require('git-worktree') loads without error via nvim --headless
- Files changed: lua/git-worktree/{init,config,types}.lua, plugin/git-worktree.lua
- **Learnings**: vim.tbl_deep_extend merges configs, vim.validate checks types at runtime

## Task - git-1
- Created lua/git-worktree/git.lua with git command wrapper functions
- Implemented worktree_list() returning stdout from `git worktree list --porcelain`
- Implemented worktree_add(path, branch, opts) with create_branch support
- Implemented worktree_remove(path, opts) with force option
- Implemented is_dirty(path) checking `git -C <path> status --porcelain`
- Implemented get_git_root() returning repo root from `git rev-parse --show-toplevel`
- All functions use vim.system() synchronously via :wait()
- All functions check exit codes and return errors on failure
- Files changed: lua/git-worktree/git.lua
- **Learnings**: vim.system() returns vim.SystemCompleted with code, stdout, stderr fields; use :wait() for sync execution

## Task - core-1
- Created lua/git-worktree/worktree.lua with parse() and list() functions
- parse() parses `git worktree list --porcelain` output into Worktree objects
- Handles all porcelain fields: worktree, HEAD, branch, detached, bare, locked, prunable
- branch field extracts name from refs/heads/X format, nil for detached HEAD
- is_current determined by comparing resolved paths (vim.fn.resolve) to handle symlinks
- Added list() function to init.lua that delegates to worktree.list()
- Tested with both normal branch and detached HEAD worktrees
- Files changed: lua/git-worktree/worktree.lua, lua/git-worktree/init.lua
- **Learnings**: Porcelain format is line-based with blank line separators; vim.fn.resolve canonicalizes paths for comparison

## Task - core-2
- Implemented create() API in lua/git-worktree/worktree.lua with async (callback) and sync modes
- create() accepts CreateWorktreeOpts: branch (required), path, create_branch, switch
- Prompts for path via vim.ui.input() if not provided, defaults to ../<branch-name> from git root
- Returns Worktree object on success, nil + error on failure
- Calls on_create hook if configured in setup()
- Switches to new worktree by default (switch = true) via pcall to avoid circular dependency
- Uses vim.fn.resolve() for path comparison to handle symlinks (/tmp -> /private/tmp on macOS)
- Added create() to public API in lua/git-worktree/init.lua
- Tested: existing branch, create_branch=true, on_create hook
- Files changed: lua/git-worktree/worktree.lua, lua/git-worktree/init.lua
- **Learnings**: vim.ui.input() requires async callback pattern; pcall protects against missing dependencies during development; symlink resolution critical for macOS /tmp paths

## Task - core-3
- Verified lua/git-worktree/buffer.lua already implemented with save_all() and repoint() functions
- save_all() iterates through all buffers, saves only modified normal file buffers (buftype=='')
- Uses vim.api.nvim_get_option_value() to check modifiable and modified state
- repoint(old_root, new_root) canonicalizes paths with vim.fn.resolve() to handle symlinks
- Filters buffers by buftype to skip terminals, quickfix, help, etc
- Calculates relative paths and reconstructs absolute paths in new worktree
- Checks vim.fn.filereadable() before repointing; closes buffers for missing files
- Notifies user when closing buffers for files not in new worktree
- Files: lua/git-worktree/buffer.lua
- **Learnings**: nvim_get_option_value() preferred over deprecated buf_get_option; vim.startswith() cleaner for path prefix checks

## Task - core-4
- Implemented switch() API in lua/git-worktree/worktree.lua
- Validates target path is valid worktree via list()
- Auto-saves modified buffers via buffer.save_all()
- Changes cwd via vim.fn.chdir()
- Repoints buffers from old to new worktree via buffer.repoint()
- Restarts LSP clients by stopping all active clients (auto-restart on buffer access)
- Emits User GitWorktreeSwitched autocmd with old/new worktree data
- Calls on_switch hook with (old_worktree, new_worktree)
- Returns (true, nil) on success, (false, error_msg) on failure
- Uses vim.fn.resolve() throughout for symlink handling
- Files: lua/git-worktree/worktree.lua, lua/git-worktree/init.lua
- **Learnings**: vim.lsp.get_clients() returns all clients; stopping clients triggers auto-restart; vim.api.nvim_exec_autocmds for User events with data field

## Task - core-5
- Implemented delete() API in lua/git-worktree/worktree.lua
- Validates path is valid worktree via list()
- Prevents deleting current worktree (returns error)
- Prevents deleting main/bare worktree (returns error)
- Calls git.worktree_remove() with force option support
- Calls on_delete hook with deleted worktree object
- Returns (true, nil) on success, (nil, error_msg) on failure
- Handles symlinks via vim.fn.resolve()
- Added delete() to public API in lua/git-worktree/init.lua
- Tested: normal delete, force delete of dirty worktree, prevent delete current, on_delete hook
- Files: lua/git-worktree/worktree.lua, lua/git-worktree/init.lua
- **Learnings**: Git worktree remove fails on dirty trees without --force; main worktree detection via is_bare field

## Task - cmd-1
- Implemented :Worktree list subcommand in plugin/git-worktree.lua
- Parses subcommand from opts.args via vim.split()
- Displays formatted list: current indicator (*), branch name (30 chars), path
- Handles detached HEAD case: shows "(detached HEAD)" when branch is nil
- Uses vim.notify() for output display
- Tested: single worktree, multiple worktrees, current indicator placement
- Files: plugin/git-worktree.lua
- **Learnings**: User commands receive opts.args as string; vim.split with trimempty simplifies arg parsing
## Task - cmd-2
- Implemented :Worktree create subcommand in plugin/git-worktree.lua
- Handles three input modes: branch only, branch+path, no args (prompts)
- Delegates to require('git-worktree').create() which prompts for path if needed
- Branch-only mode: passes branch to create(), which prompts for path via vim.ui.input()
- No-args mode: prompts for branch via vim.ui.input(), then calls create() which prompts for path
- Explicit path mode: passes both branch and path directly to create()
- Error handling: displays errors via vim.notify() with ERROR level
- Files: plugin/git-worktree.lua
- **Learnings**: vim.ui.input() async callback pattern handles nested prompts; delegation to API layer keeps command handler thin

## Task - cmd-3
- Implemented :Worktree switch <path> subcommand in plugin/git-worktree.lua
- Validates path argument is provided (error if missing)
- Delegates to require('git-worktree').switch() API
- Error handling via vim.notify() with ERROR level
- Added tab completion function to nvim_create_user_command
- Completion suggests subcommands (list, create, switch, delete, pick) when completing first arg
- Completion suggests worktree paths when completing args for switch/delete subcommands
- Uses vim.startswith() for filtering completions by arg_lead
- Uses pcall to handle case where git-worktree module fails to load during completion
- Files: plugin/git-worktree.lua
- **Learnings**: nvim_create_user_command complete function receives arg_lead, cmd_line, cursor_pos; need to parse cmd_line to determine context; vim.fn.getcompletion() useful for testing completions

## Task - cmd-4
- Implemented :Worktree delete <path> subcommand in plugin/git-worktree.lua
- Validates path argument is provided (error if missing)
- Parses --force/-f flag from args[3] onwards
- Delegates to require('git-worktree').delete(path, { force = force })
- Error detection: checks if error contains "modified" or "dirty" keywords
- Suggests "--force to delete anyway" when dirty worktree detected
- Tab completion for paths already implemented via shared completion function
- Git error format: "contains modified or untracked files, use --force to delete it"
- Files: plugin/git-worktree.lua
- **Learnings**: Git worktree remove error for dirty trees contains "modified" keyword; error message enhancement done in command layer not API layer
