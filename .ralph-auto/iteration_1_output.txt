{"type":"step_start","timestamp":1768574054915,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73a7202001NRJQnQEfC89zAN","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a6697001JdVqvXeQ04RBGi","type":"step-start","snapshot":"482e6e18020cd088a579b3db20ee982ba1ff996b"}}
{"type":"tool_use","timestamp":1768574055967,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73a73a0001YezcZ9v7dIw64n","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a6697001JdVqvXeQ04RBGi","type":"tool","callID":"toolu_01P1SRshWJyctwfJsuMWXL3H","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/worktree.lua"},"output":"<file>\n00001| ---Worktree parsing and management module\n00002| local M = {}\n00003| \n00004| local git = require(\"git-worktree.git\")\n00005| \n00006| ---Parse git worktree list --porcelain output into Worktree objects\n00007| ---@param porcelain string Output from git worktree list --porcelain\n00008| ---@return Worktree[]\n00009| function M.parse(porcelain)\n00010|   local worktrees = {}\n00011|   local current = {}\n00012|   local cwd = vim.fn.getcwd()\n00013| \n00014|   for line in porcelain:gmatch(\"[^\\r\\n]+\") do\n00015|     if line:match(\"^worktree \") then\n00016|       -- Start of a new worktree entry\n00017|       if next(current) ~= nil then\n00018|         -- Finalize previous entry\n00019|         table.insert(worktrees, M._finalize_worktree(current, cwd))\n00020|       end\n00021|       current = { path = line:match(\"^worktree (.+)\") }\n00022|     elseif line:match(\"^HEAD \") then\n00023|       current.head = line:match(\"^HEAD (%x+)\")\n00024|     elseif line:match(\"^branch \") then\n00025|       local branch_ref = line:match(\"^branch (.+)\")\n00026|       -- Extract branch name from refs/heads/branch-name\n00027|       current.branch = branch_ref:match(\"refs/heads/(.+)\") or branch_ref\n00028|     elseif line:match(\"^detached\") then\n00029|       current.is_detached = true\n00030|     elseif line:match(\"^bare\") then\n00031|       current.is_bare = true\n00032|     elseif line:match(\"^locked\") then\n00033|       current.is_locked = true\n00034|     elseif line:match(\"^prunable\") then\n00035|       current.is_prunable = true\n00036|     end\n00037|   end\n00038| \n00039|   -- Finalize last entry\n00040|   if next(current) ~= nil then\n00041|     table.insert(worktrees, M._finalize_worktree(current, cwd))\n00042|   end\n00043| \n00044|   return worktrees\n00045| end\n00046| \n00047| ---Finalize a worktree entry by setting default fields\n00048| ---@param wt table Partial worktree data\n00049| ---@param cwd string Current working directory\n00050| ---@return Worktree\n00051| function M._finalize_worktree(wt, cwd)\n00052|   -- Resolve paths to handle symlinks\n00053|   local wt_path = vim.fn.resolve(wt.path)\n00054|   local resolved_cwd = vim.fn.resolve(cwd)\n00055| \n00056|   return {\n00057|     path = wt.path,\n00058|     head = wt.head or \"\",\n00059|     branch = wt.branch,\n00060|     is_bare = wt.is_bare or false,\n00061|     is_current = wt_path == resolved_cwd,\n00062|     is_locked = wt.is_locked or false,\n00063|     is_prunable = wt.is_prunable or false,\n00064|     is_detached = wt.is_detached or false,\n00065|   }\n00066| end\n00067| \n00068| ---List all worktrees in the current repository\n00069| ---@return Worktree[]?, string? worktrees, error\n00070| function M.list()\n00071|   local stdout, err = git.worktree_list()\n00072|   if err then\n00073|     return nil, err\n00074|   end\n00075| \n00076|   local worktrees = M.parse(stdout)\n00077|   return worktrees, nil\n00078| end\n00079| \n00080| ---Create a new worktree\n00081| ---@param opts CreateWorktreeOpts Options for creating the worktree\n00082| ---@param callback? fun(worktree: Worktree?, error: string?) Async callback\n00083| ---@return Worktree?, string? worktree, error (only in sync mode when no callback)\n00084| function M.create(opts, callback)\n00085|   local config = require(\"git-worktree.config\")\n00086| \n00087|   -- Validate required fields\n00088|   if not opts or not opts.branch then\n00089|     local err = \"branch is required\"\n00090|     if callback then\n00091|       callback(nil, err)\n00092|       return\n00093|     end\n00094|     return nil, err\n00095|   end\n00096| \n00097|   -- Determine path (prompt if not provided)\n00098|   if not opts.path then\n00099|     local git_root, root_err = git.get_git_root()\n00100|     if root_err then\n00101|       if callback then\n00102|         callback(nil, root_err)\n00103|         return\n00104|       end\n00105|       return nil, root_err\n00106|     end\n00107| \n00108|     local default_path = vim.fn.fnamemodify(git_root, \":h\") .. \"/\" .. opts.branch\n00109| \n00110|     vim.ui.input({\n00111|       prompt = \"Worktree path: \",\n00112|       default = default_path,\n00113|     }, function(input_path)\n00114|       if not input_path or input_path == \"\" then\n00115|         if callback then\n00116|           callback(nil, \"path is required\")\n00117|         end\n00118|         return\n00119|       end\n00120| \n00121|       -- Continue with the provided path\n00122|       local new_opts = vim.tbl_extend(\"force\", opts, { path = input_path })\n00123|       M._create_worktree(new_opts, callback)\n00124|     end)\n00125| \n00126|     -- Async mode - callback will be called\n00127|     if callback then\n00128|       return\n00129|     end\n00130| \n00131|     -- Sync mode not supported when prompting\n00132|     return nil, \"path must be provided in synchronous mode\"\n00133|   end\n00134| \n00135|   -- Path provided - create directly\n00136|   return M._create_worktree(opts, callback)\n00137| end\n00138| \n00139| ---Internal function to create worktree after path is determined\n00140| ---@param opts CreateWorktreeOpts\n00141| ---@param callback? fun(worktree: Worktree?, error: string?)\n00142| ---@return Worktree?, string?\n00143| function M._create_worktree(opts, callback)\n00144|   local config = require(\"git-worktree.config\")\n00145| \n00146|   -- Create the worktree\n00147|   local success, err = git.worktree_add(opts.path, opts.branch, {\n00148|     create_branch = opts.create_branch or false,\n00149|   })\n00150| \n00151|   if not success then\n00152|     if callback then\n00153|       callback(nil, err)\n00154|       return\n00155|     end\n00156|     return nil, err\n00157|   end\n00158| \n00159|   -- Get the created worktree object\n00160|   local worktrees, list_err = M.list()\n00161|   if list_err then\n00162|     if callback then\n00163|       callback(nil, list_err)\n00164|       return\n00165|     end\n00166|     return nil, list_err\n00167|   end\n00168| \n00169|   -- Find the newly created worktree (resolve paths to handle symlinks)\n00170|   local resolved_path = vim.fn.resolve(opts.path)\n00171|   local created_worktree = nil\n00172|   for _, wt in ipairs(worktrees) do\n00173|     if vim.fn.resolve(wt.path) == resolved_path then\n00174|       created_worktree = wt\n00175|       break\n00176|     end\n00177|   end\n00178| \n00179|   if not created_worktree then\n00180|     local not_found_err = \"Failed to find created worktree\"\n00181|     if callback then\n00182|       callback(nil, not_found_err)\n00183|       return\n00184|     end\n00185|     return nil, not_found_err\n00186|   end\n00187| \n00188|   -- Call on_create hook if configured\n00189|   if config.options.hooks and config.options.hooks.on_create then\n00190|     config.options.hooks.on_create(created_worktree)\n00191|   end\n00192| \n00193|   -- Switch to new worktree if requested (default: true)\n00194|   if opts.switch ~= false then\n00195|     -- Try to get switch function (may not exist yet in early development)\n00196|     local ok, main = pcall(require, \"git-worktree\")\n00197|     if ok and main.switch then\n00198|       local switch_success, switch_err = main.switch(created_worktree.path)\n00199|       if not switch_success then\n00200|         -- Still return the created worktree, but note the switch error\n00201|         vim.notify(\"Worktree created but failed to switch: \" .. (switch_err or \"unknown error\"), vim.log.levels.WARN)\n00202|       end\n00203|     end\n00204|   end\n00205| \n00206|   if callback then\n00207|     callback(created_worktree, nil)\n00208|     return\n00209|   end\n00210|   return created_worktree, nil\n00211| end\n00212| \n00213| ---Switch to a different worktree\n00214| ---@param path string Path to the target worktree\n00215| ---@return boolean, string? success, error\n00216| function M.switch(path)\n00217|   local config = require(\"git-worktree.config\")\n00218|   local buffer = require(\"git-worktree.buffer\")\n00219| \n00220|   -- Validate that path is a valid worktree\n00221|   local worktrees, list_err = M.list()\n00222|   if list_err then\n00223|     return false, list_err\n00224|   end\n00225| \n00226|   -- Resolve target path to handle symlinks\n00227|   local resolved_target = vim.fn.resolve(path)\n00228| \n00229|   local target_worktree = nil\n00230|   local current_worktree = nil\n00231| \n00232|   for _, wt in ipairs(worktrees) do\n00233|     local resolved_wt_path = vim.fn.resolve(wt.path)\n00234|     if resolved_wt_path == resolved_target then\n00235|       target_worktree = wt\n00236|     end\n00237|     if wt.is_current then\n00238|       current_worktree = wt\n00239|     end\n00240|   end\n00241| \n00242|   if not target_worktree then\n00243|     return false, \"Path is not a valid worktree: \" .. path\n00244|   end\n00245| \n00246|   -- Already in target worktree\n00247|   if target_worktree.is_current then\n00248|     return true, nil\n00249|   end\n00250| \n00251|   -- Save current worktree reference for hook\n00252|   if not current_worktree then\n00253|     return false, \"Could not determine current worktree\"\n00254|   end\n00255| \n00256|   -- Auto-save all modified buffers\n00257|   buffer.save_all()\n00258| \n00259|   -- Change directory to target worktree\n00260|   local ok, chdir_err = pcall(vim.fn.chdir, target_worktree.path)\n00261|   if not ok then\n00262|     return false, \"Failed to change directory: \" .. tostring(chdir_err)\n00263|   end\n00264| \n00265|   -- Repoint buffers to new worktree paths\n00266|   buffer.repoint(current_worktree.path, target_worktree.path)\n00267| \n00268|   -- Restart LSP clients\n00269|   -- Get all active LSP clients\n00270|   local clients = vim.lsp.get_clients()\n00271|   for _, client in ipairs(clients) do\n00272|     -- Stop each client\n00273|     client.stop()\n00274|   end\n00275| \n00276|   -- LSP clients will auto-restart when buffers are accessed\n00277| \n00278|   -- Emit autocmd event\n00279|   vim.api.nvim_exec_autocmds(\"User\", {\n00280|     pattern = \"GitWorktreeSwitched\",\n00281|     data = {\n00282|       old = current_worktree,\n00283|       new = target_worktree,\n00284|     },\n00285|   })\n00286| \n00287|   -- Call on_switch hook\n00288|   if config.options.hooks and config.options.hooks.on_switch then\n00289|     config.options.hooks.on_switch(current_worktree, target_worktree)\n00290|   end\n00291| \n00292|   return true, nil\n00293| end\n00294| \n00295| ---Delete a worktree\n00296| ---@param path string Path to the worktree to delete\n00297| ---@param opts? DeleteWorktreeOpts Options\n00298| ---@return boolean?, string? success, error\n00299| function M.delete(path, opts)\n00300|   local config = require(\"git-worktree.config\")\n00301| \n00302|   opts = opts or {}\n00303| \n00304|   -- Get all worktrees to validate\n00305|   local worktrees, list_err = M.list()\n00306|   if list_err then\n00307|     return nil, list_err\n00308|   end\n00309| \n00310|   -- Resolve target path to handle symlinks\n00311|   local resolved_target = vim.fn.resolve(path)\n00312| \n00313|   local target_worktree = nil\n00314| \n00315|   for _, wt in ipairs(worktrees) do\n00316|     local resolved_wt_path = vim.fn.resolve(wt.path)\n00317|     if resolved_wt_path == resolved_target then\n00318|       target_worktree = wt\n00319|       break\n00320|     end\n00321|   end\n00322| \n00323|   if not target_worktree then\n00324|     return nil, \"Path is not a valid worktree: \" .. path\n00325|   end\n00326| \n00327|   -- Prevent deleting current worktree\n00328|   if target_worktree.is_current then\n00329|     return nil, \"Cannot delete current worktree. Switch to another worktree first.\"\n00330|   end\n00331| \n00332|   -- Prevent deleting main worktree (bare repo)\n00333|   if target_worktree.is_bare then\n00334|     return nil, \"Cannot delete main (bare) worktree\"\n00335|   end\n00336| \n00337|   -- Remove the worktree\n00338|   local success, err = git.worktree_remove(path, {\n00339|     force = opts.force or false,\n00340|   })\n00341| \n00342|   if not success then\n00343|     return nil, err\n00344|   end\n00345| \n00346|   -- Call on_delete hook if configured\n00347|   if config.options.hooks and config.options.hooks.on_delete then\n00348|     config.options.hooks.on_delete(target_worktree)\n00349|   end\n00350| \n00351|   return true, nil\n00352| end\n00353| \n00354| return M\n00355| \n\n(End of file - total 355 lines)\n</file>","title":"lua/git-worktree/worktree.lua","metadata":{"preview":"---Worktree parsing and management module\nlocal M = {}\n\nlocal git = require(\"git-worktree.git\")\n\n---Parse git worktree list --porcelain output into Worktree objects\n---@param porcelain string Output from git worktree list --porcelain\n---@return Worktree[]\nfunction M.parse(porcelain)\n  local worktrees = {}\n  local current = {}\n  local cwd = vim.fn.getcwd()\n\n  for line in porcelain:gmatch(\"[^\\r\\n]+\") do\n    if line:match(\"^worktree \") then\n      -- Start of a new worktree entry\n      if next(current) ~= nil then\n        -- Finalize previous entry\n        table.insert(worktrees, M._finalize_worktree(current, cwd))\n      end","truncated":false},"time":{"start":1768574055957,"end":1768574055964}}}}
{"type":"step_finish","timestamp":1768574055994,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73a761e001EtX9scy0n7Db4w","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a6697001JdVqvXeQ04RBGi","type":"step-finish","reason":"tool-calls","snapshot":"f53da58ff2438baa7d03efa8183302e19b84f5e5","cost":0,"tokens":{"input":1,"output":95,"reasoning":0,"cache":{"read":12453,"write":2841}}}}
{"type":"step_start","timestamp":1768574058442,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73a7fc9001SW5Wt7t3o6VgbC","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a7651001CNlmqW2G9q26AV","type":"step-start","snapshot":"f01478a93a1ee9811122bde15810af5f1f94285e"}}
{"type":"text","timestamp":1768574059866,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73a7fca001XgcRZHvANUPKUX","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a7651001CNlmqW2G9q26AV","type":"text","text":"I see the issue. Line 85 has `local config = require(\"git-worktree.config\")` which is assigned but never used because the actual config usage is in `M._create_worktree` function at line 144. I need to remove the unused variable on line 85.","time":{"start":1768574059864,"end":1768574059864}}}
{"type":"tool_use","timestamp":1768574062381,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73a855a0019CswMAnRF8fAEV","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a7651001CNlmqW2G9q26AV","type":"tool","callID":"toolu_016BMPjsY6wZhszDMkpUyyKm","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/worktree.lua","oldString":"function M.create(opts, callback)\n  local config = require(\"git-worktree.config\")\n\n  -- Validate required fields","newString":"function M.create(opts, callback)\n  -- Validate required fields"},"output":"Edit applied successfully.","title":"lua/git-worktree/worktree.lua","metadata":{"diagnostics":{"/Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/worktree.lua":[{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":48,"line":68},"start":{"character":43,"line":68}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":45,"line":82},"start":{"character":40,"line":82}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":42,"line":212},"start":{"character":37,"line":212}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":43,"line":295},"start":{"character":38,"line":295}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":72},"start":{"character":4,"line":72}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":8,"line":76},"start":{"character":2,"line":76}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 0 returned here instead.","range":{"end":{"character":12,"line":89},"start":{"character":6,"line":89}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":91},"start":{"character":4,"line":91}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 0 returned here instead.","range":{"end":{"character":14,"line":100},"start":{"character":8,"line":100}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":12,"line":102},"start":{"character":6,"line":102}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 0 returned here instead.","range":{"end":{"character":12,"line":125},"start":{"character":6,"line":125}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":129},"start":{"character":4,"line":129}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 0 to 2 returned here instead.","range":{"end":{"character":8,"line":133},"start":{"character":2,"line":133}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":220},"start":{"character":4,"line":220}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":240},"start":{"character":4,"line":240}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":245},"start":{"character":4,"line":245}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":250},"start":{"character":4,"line":250}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":259},"start":{"character":4,"line":259}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":8,"line":289},"start":{"character":2,"line":289}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":304},"start":{"character":4,"line":304}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":321},"start":{"character":4,"line":321}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":326},"start":{"character":4,"line":326}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":331},"start":{"character":4,"line":331}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":340},"start":{"character":4,"line":340}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":8,"line":348},"start":{"character":2,"line":348}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":5,"line":276},"start":{"character":2,"line":276}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":17,"line":11},"start":{"character":14,"line":11}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":21,"line":52},"start":{"character":18,"line":52}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":26,"line":53},"start":{"character":23,"line":53}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":7,"line":107},"start":{"character":4,"line":107}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":27,"line":167},"start":{"character":24,"line":167}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":29,"line":224},"start":{"character":26,"line":224}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":21,"line":267},"start":{"character":18,"line":267}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":29,"line":308},"start":{"character":26,"line":308}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":32,"line":230},"start":{"character":29,"line":230}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":33,"line":257},"start":{"character":30,"line":257}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":32,"line":313},"start":{"character":29,"line":313}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":28,"line":105},"start":{"character":25,"line":105}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":10,"line":170},"start":{"character":7,"line":170}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":11,"line":198},"start":{"character":8,"line":198}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":26,"line":119},"start":{"character":23,"line":119}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":100,"line":198},"start":{"character":97,"line":198}},"severity":2,"source":"Lua Diagnostics."},{"code":"return-type-mismatch","message":"Annotations specify that return value #3 has a type of `error`, returning value of type `nil` here instead.\n- `nil` cannot match `error`\n- Type `nil` cannot match `error`","range":{"end":{"character":43,"line":133},"start":{"character":9,"line":133}},"severity":2,"source":"Lua Diagnostics."},{"code":"param-type-mismatch","message":"Cannot assign `string?` to parameter `string`.\n- Optional type cannot match `string`\n- Type `nil` cannot match `string`","range":{"end":{"character":34,"line":75},"start":{"character":28,"line":75}},"severity":2,"source":"Lua Diagnostics."},{"code":"param-type-mismatch","message":"Cannot assign `Worktree[]?` to parameter `<T:table>`.\n- Optional type cannot match `table`\n- Type `nil` cannot match `table`","range":{"end":{"character":31,"line":169},"start":{"character":22,"line":169}},"severity":2,"source":"Lua Diagnostics."},{"code":"param-type-mismatch","message":"Cannot assign `Worktree[]?` to parameter `<T:table>`.\n- Optional type cannot match `table`\n- Type `nil` cannot match `table`","range":{"end":{"character":31,"line":229},"start":{"character":22,"line":229}},"severity":2,"source":"Lua Diagnostics."},{"code":"param-type-mismatch","message":"Cannot assign `Worktree[]?` to parameter `<T:table>`.\n- Optional type cannot match `table`\n- Type `nil` cannot match `table`","range":{"end":{"character":31,"line":312},"start":{"character":22,"line":312}},"severity":2,"source":"Lua Diagnostics."}],"/Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/buffer.lua":[{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":26,"line":24},"start":{"character":23,"line":24}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":26,"line":25},"start":{"character":23,"line":25}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":9,"line":12},"start":{"character":6,"line":12}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":10,"line":28},"start":{"character":7,"line":28}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":28,"line":5},"start":{"character":25,"line":5}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":13,"line":10},"start":{"character":10,"line":10}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":28,"line":27},"start":{"character":25,"line":27}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":12,"line":47},"start":{"character":9,"line":47}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":9,"line":8},"start":{"character":6,"line":8}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":13,"line":9},"start":{"character":10,"line":9}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":11,"line":13},"start":{"character":8,"line":13}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":25,"line":29},"start":{"character":22,"line":29}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":25,"line":37},"start":{"character":22,"line":37}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":34,"line":44},"start":{"character":31,"line":44}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":13,"line":65},"start":{"character":10,"line":65}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":13,"line":57},"start":{"character":10,"line":57}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":13,"line":60},"start":{"character":10,"line":60}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":13,"line":68},"start":{"character":10,"line":68}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":14,"line":55},"start":{"character":11,"line":55}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":15,"line":61},"start":{"character":12,"line":61}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":94,"line":65},"start":{"character":91,"line":65}},"severity":2,"source":"Lua Diagnostics."}],"/Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/config.lua":[{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":15,"line":16},"start":{"character":12,"line":16}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":5,"line":22},"start":{"character":2,"line":22}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":7,"line":27},"start":{"character":4,"line":27}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":17,"line":34},"start":{"character":14,"line":34}},"severity":2,"source":"Lua Diagnostics."}],"/Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/git.lua":[{"code":"undefined-doc-name","message":"Undefined type or alias `vim.SystemCompleted`.","range":{"end":{"character":30,"line":6},"start":{"character":11,"line":6}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":41,"line":16},"start":{"character":36,"line":16}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":42,"line":29},"start":{"character":37,"line":29}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":42,"line":53},"start":{"character":37,"line":53}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":39,"line":83},"start":{"character":34,"line":83}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":20},"start":{"character":4,"line":20}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":8,"line":22},"start":{"character":2,"line":22}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":45},"start":{"character":4,"line":45}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":8,"line":47},"start":{"character":2,"line":47}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":66},"start":{"character":4,"line":66}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":8,"line":68},"start":{"character":2,"line":68}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":10,"line":87},"start":{"character":4,"line":87}},"severity":2,"source":"Lua Diagnostics."},{"code":"missing-return-value","message":"Annotations specify that at least 3 return value(s) are required, found 2 returned here instead.","range":{"end":{"character":8,"line":91},"start":{"character":2,"line":91}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":17,"line":9},"start":{"character":14,"line":9}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":20,"line":10},"start":{"character":17,"line":10}},"severity":2,"source":"Lua Diagnostics."}],"/Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/init.lua":[{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":48,"line":13},"start":{"character":43,"line":13}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":45,"line":21},"start":{"character":40,"line":21}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":42,"line":28},"start":{"character":37,"line":28}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `error`.","range":{"end":{"character":43,"line":36},"start":{"character":38,"line":36}},"severity":2,"source":"Lua Diagnostics."}],"/Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/snacks.lua":[{"code":"undefined-doc-param","message":"Undefined param `item`.","range":{"end":{"character":18,"line":72},"start":{"character":14,"line":72}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `snacks.picker.finder`.","range":{"end":{"character":31,"line":18},"start":{"character":11,"line":18}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `snacks.picker.Config`.","range":{"end":{"character":31,"line":52},"start":{"character":11,"line":52}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `snacks.picker.finder.Item`.","range":{"end":{"character":55,"line":26},"start":{"character":30,"line":26}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `snacks.Picker`.","range":{"end":{"character":34,"line":58},"start":{"character":21,"line":58}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `snacks.picker.finder.Item`.","range":{"end":{"character":44,"line":59},"start":{"character":19,"line":59}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-doc-name","message":"Undefined type or alias `snacks.picker.finder.Item`.","range":{"end":{"character":44,"line":72},"start":{"character":19,"line":72}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":7,"line":9},"start":{"character":4,"line":9}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":25,"line":53},"start":{"character":22,"line":53}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":9,"line":22},"start":{"character":6,"line":22}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":84,"line":9},"start":{"character":81,"line":9}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":21,"line":41},"start":{"character":18,"line":41}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":57,"line":22},"start":{"character":54,"line":22}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":15,"line":67},"start":{"character":12,"line":67}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":92,"line":67},"start":{"character":89,"line":67}},"severity":2,"source":"Lua Diagnostics."}],"/Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/plugin/git-worktree.lua":[{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":3,"line":1},"start":{"character":0,"line":1}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":18,"line":2},"start":{"character":15,"line":2}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":7,"line":19},"start":{"character":4,"line":19}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":7,"line":86},"start":{"character":4,"line":86}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":9,"line":8},"start":{"character":6,"line":8}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":9,"line":52},"start":{"character":6,"line":52}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":9,"line":58},"start":{"character":6,"line":58}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":9,"line":64},"start":{"character":6,"line":64}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":9,"line":83},"start":{"character":6,"line":83}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":20,"line":92},"start":{"character":17,"line":92}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":45,"line":19},"start":{"character":42,"line":19}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":9,"line":35},"start":{"character":6,"line":35}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":70,"line":86},"start":{"character":67,"line":86}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":11,"line":31},"start":{"character":8,"line":31}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":42,"line":8},"start":{"character":39,"line":8}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":65,"line":52},"start":{"character":62,"line":52}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":79,"line":58},"start":{"character":76,"line":58}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":65,"line":64},"start":{"character":62,"line":64}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":25,"line":83},"start":{"character":22,"line":83}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":14,"line":104},"start":{"character":11,"line":104}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":14,"line":121},"start":{"character":11,"line":121}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":84,"line":31},"start":{"character":81,"line":31}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":13,"line":44},"start":{"character":10,"line":44}},"severity":2,"source":"Lua Diagnostics."},{"code":"undefined-global","message":"Undefined global `vim`.","range":{"end":{"character":86,"line":44},"start":{"character":83,"line":44}},"severity":2,"source":"Lua Diagnostics."}]},"diff":"Index: /Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/worktree.lua\n===================================================================\n--- /Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/worktree.lua\n+++ /Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/worktree.lua\n@@ -81,10 +81,8 @@\n ---@param opts CreateWorktreeOpts Options for creating the worktree\n ---@param callback? fun(worktree: Worktree?, error: string?) Async callback\n ---@return Worktree?, string? worktree, error (only in sync mode when no callback)\n function M.create(opts, callback)\n-  local config = require(\"git-worktree.config\")\n-\n   -- Validate required fields\n   if not opts or not opts.branch then\n     local err = \"branch is required\"\n     if callback then\n","filediff":{"file":"/Users/maxwellbrown/Code/github.com/imax153/git-worktree.nvim/lua/git-worktree/worktree.lua","before":"---Worktree parsing and management module\nlocal M = {}\n\nlocal git = require(\"git-worktree.git\")\n\n---Parse git worktree list --porcelain output into Worktree objects\n---@param porcelain string Output from git worktree list --porcelain\n---@return Worktree[]\nfunction M.parse(porcelain)\n  local worktrees = {}\n  local current = {}\n  local cwd = vim.fn.getcwd()\n\n  for line in porcelain:gmatch(\"[^\\r\\n]+\") do\n    if line:match(\"^worktree \") then\n      -- Start of a new worktree entry\n      if next(current) ~= nil then\n        -- Finalize previous entry\n        table.insert(worktrees, M._finalize_worktree(current, cwd))\n      end\n      current = { path = line:match(\"^worktree (.+)\") }\n    elseif line:match(\"^HEAD \") then\n      current.head = line:match(\"^HEAD (%x+)\")\n    elseif line:match(\"^branch \") then\n      local branch_ref = line:match(\"^branch (.+)\")\n      -- Extract branch name from refs/heads/branch-name\n      current.branch = branch_ref:match(\"refs/heads/(.+)\") or branch_ref\n    elseif line:match(\"^detached\") then\n      current.is_detached = true\n    elseif line:match(\"^bare\") then\n      current.is_bare = true\n    elseif line:match(\"^locked\") then\n      current.is_locked = true\n    elseif line:match(\"^prunable\") then\n      current.is_prunable = true\n    end\n  end\n\n  -- Finalize last entry\n  if next(current) ~= nil then\n    table.insert(worktrees, M._finalize_worktree(current, cwd))\n  end\n\n  return worktrees\nend\n\n---Finalize a worktree entry by setting default fields\n---@param wt table Partial worktree data\n---@param cwd string Current working directory\n---@return Worktree\nfunction M._finalize_worktree(wt, cwd)\n  -- Resolve paths to handle symlinks\n  local wt_path = vim.fn.resolve(wt.path)\n  local resolved_cwd = vim.fn.resolve(cwd)\n\n  return {\n    path = wt.path,\n    head = wt.head or \"\",\n    branch = wt.branch,\n    is_bare = wt.is_bare or false,\n    is_current = wt_path == resolved_cwd,\n    is_locked = wt.is_locked or false,\n    is_prunable = wt.is_prunable or false,\n    is_detached = wt.is_detached or false,\n  }\nend\n\n---List all worktrees in the current repository\n---@return Worktree[]?, string? worktrees, error\nfunction M.list()\n  local stdout, err = git.worktree_list()\n  if err then\n    return nil, err\n  end\n\n  local worktrees = M.parse(stdout)\n  return worktrees, nil\nend\n\n---Create a new worktree\n---@param opts CreateWorktreeOpts Options for creating the worktree\n---@param callback? fun(worktree: Worktree?, error: string?) Async callback\n---@return Worktree?, string? worktree, error (only in sync mode when no callback)\nfunction M.create(opts, callback)\n  local config = require(\"git-worktree.config\")\n\n  -- Validate required fields\n  if not opts or not opts.branch then\n    local err = \"branch is required\"\n    if callback then\n      callback(nil, err)\n      return\n    end\n    return nil, err\n  end\n\n  -- Determine path (prompt if not provided)\n  if not opts.path then\n    local git_root, root_err = git.get_git_root()\n    if root_err then\n      if callback then\n        callback(nil, root_err)\n        return\n      end\n      return nil, root_err\n    end\n\n    local default_path = vim.fn.fnamemodify(git_root, \":h\") .. \"/\" .. opts.branch\n\n    vim.ui.input({\n      prompt = \"Worktree path: \",\n      default = default_path,\n    }, function(input_path)\n      if not input_path or input_path == \"\" then\n        if callback then\n          callback(nil, \"path is required\")\n        end\n        return\n      end\n\n      -- Continue with the provided path\n      local new_opts = vim.tbl_extend(\"force\", opts, { path = input_path })\n      M._create_worktree(new_opts, callback)\n    end)\n\n    -- Async mode - callback will be called\n    if callback then\n      return\n    end\n\n    -- Sync mode not supported when prompting\n    return nil, \"path must be provided in synchronous mode\"\n  end\n\n  -- Path provided - create directly\n  return M._create_worktree(opts, callback)\nend\n\n---Internal function to create worktree after path is determined\n---@param opts CreateWorktreeOpts\n---@param callback? fun(worktree: Worktree?, error: string?)\n---@return Worktree?, string?\nfunction M._create_worktree(opts, callback)\n  local config = require(\"git-worktree.config\")\n\n  -- Create the worktree\n  local success, err = git.worktree_add(opts.path, opts.branch, {\n    create_branch = opts.create_branch or false,\n  })\n\n  if not success then\n    if callback then\n      callback(nil, err)\n      return\n    end\n    return nil, err\n  end\n\n  -- Get the created worktree object\n  local worktrees, list_err = M.list()\n  if list_err then\n    if callback then\n      callback(nil, list_err)\n      return\n    end\n    return nil, list_err\n  end\n\n  -- Find the newly created worktree (resolve paths to handle symlinks)\n  local resolved_path = vim.fn.resolve(opts.path)\n  local created_worktree = nil\n  for _, wt in ipairs(worktrees) do\n    if vim.fn.resolve(wt.path) == resolved_path then\n      created_worktree = wt\n      break\n    end\n  end\n\n  if not created_worktree then\n    local not_found_err = \"Failed to find created worktree\"\n    if callback then\n      callback(nil, not_found_err)\n      return\n    end\n    return nil, not_found_err\n  end\n\n  -- Call on_create hook if configured\n  if config.options.hooks and config.options.hooks.on_create then\n    config.options.hooks.on_create(created_worktree)\n  end\n\n  -- Switch to new worktree if requested (default: true)\n  if opts.switch ~= false then\n    -- Try to get switch function (may not exist yet in early development)\n    local ok, main = pcall(require, \"git-worktree\")\n    if ok and main.switch then\n      local switch_success, switch_err = main.switch(created_worktree.path)\n      if not switch_success then\n        -- Still return the created worktree, but note the switch error\n        vim.notify(\"Worktree created but failed to switch: \" .. (switch_err or \"unknown error\"), vim.log.levels.WARN)\n      end\n    end\n  end\n\n  if callback then\n    callback(created_worktree, nil)\n    return\n  end\n  return created_worktree, nil\nend\n\n---Switch to a different worktree\n---@param path string Path to the target worktree\n---@return boolean, string? success, error\nfunction M.switch(path)\n  local config = require(\"git-worktree.config\")\n  local buffer = require(\"git-worktree.buffer\")\n\n  -- Validate that path is a valid worktree\n  local worktrees, list_err = M.list()\n  if list_err then\n    return false, list_err\n  end\n\n  -- Resolve target path to handle symlinks\n  local resolved_target = vim.fn.resolve(path)\n\n  local target_worktree = nil\n  local current_worktree = nil\n\n  for _, wt in ipairs(worktrees) do\n    local resolved_wt_path = vim.fn.resolve(wt.path)\n    if resolved_wt_path == resolved_target then\n      target_worktree = wt\n    end\n    if wt.is_current then\n      current_worktree = wt\n    end\n  end\n\n  if not target_worktree then\n    return false, \"Path is not a valid worktree: \" .. path\n  end\n\n  -- Already in target worktree\n  if target_worktree.is_current then\n    return true, nil\n  end\n\n  -- Save current worktree reference for hook\n  if not current_worktree then\n    return false, \"Could not determine current worktree\"\n  end\n\n  -- Auto-save all modified buffers\n  buffer.save_all()\n\n  -- Change directory to target worktree\n  local ok, chdir_err = pcall(vim.fn.chdir, target_worktree.path)\n  if not ok then\n    return false, \"Failed to change directory: \" .. tostring(chdir_err)\n  end\n\n  -- Repoint buffers to new worktree paths\n  buffer.repoint(current_worktree.path, target_worktree.path)\n\n  -- Restart LSP clients\n  -- Get all active LSP clients\n  local clients = vim.lsp.get_clients()\n  for _, client in ipairs(clients) do\n    -- Stop each client\n    client.stop()\n  end\n\n  -- LSP clients will auto-restart when buffers are accessed\n\n  -- Emit autocmd event\n  vim.api.nvim_exec_autocmds(\"User\", {\n    pattern = \"GitWorktreeSwitched\",\n    data = {\n      old = current_worktree,\n      new = target_worktree,\n    },\n  })\n\n  -- Call on_switch hook\n  if config.options.hooks and config.options.hooks.on_switch then\n    config.options.hooks.on_switch(current_worktree, target_worktree)\n  end\n\n  return true, nil\nend\n\n---Delete a worktree\n---@param path string Path to the worktree to delete\n---@param opts? DeleteWorktreeOpts Options\n---@return boolean?, string? success, error\nfunction M.delete(path, opts)\n  local config = require(\"git-worktree.config\")\n\n  opts = opts or {}\n\n  -- Get all worktrees to validate\n  local worktrees, list_err = M.list()\n  if list_err then\n    return nil, list_err\n  end\n\n  -- Resolve target path to handle symlinks\n  local resolved_target = vim.fn.resolve(path)\n\n  local target_worktree = nil\n\n  for _, wt in ipairs(worktrees) do\n    local resolved_wt_path = vim.fn.resolve(wt.path)\n    if resolved_wt_path == resolved_target then\n      target_worktree = wt\n      break\n    end\n  end\n\n  if not target_worktree then\n    return nil, \"Path is not a valid worktree: \" .. path\n  end\n\n  -- Prevent deleting current worktree\n  if target_worktree.is_current then\n    return nil, \"Cannot delete current worktree. Switch to another worktree first.\"\n  end\n\n  -- Prevent deleting main worktree (bare repo)\n  if target_worktree.is_bare then\n    return nil, \"Cannot delete main (bare) worktree\"\n  end\n\n  -- Remove the worktree\n  local success, err = git.worktree_remove(path, {\n    force = opts.force or false,\n  })\n\n  if not success then\n    return nil, err\n  end\n\n  -- Call on_delete hook if configured\n  if config.options.hooks and config.options.hooks.on_delete then\n    config.options.hooks.on_delete(target_worktree)\n  end\n\n  return true, nil\nend\n\nreturn M\n","after":"---Worktree parsing and management module\nlocal M = {}\n\nlocal git = require(\"git-worktree.git\")\n\n---Parse git worktree list --porcelain output into Worktree objects\n---@param porcelain string Output from git worktree list --porcelain\n---@return Worktree[]\nfunction M.parse(porcelain)\n  local worktrees = {}\n  local current = {}\n  local cwd = vim.fn.getcwd()\n\n  for line in porcelain:gmatch(\"[^\\r\\n]+\") do\n    if line:match(\"^worktree \") then\n      -- Start of a new worktree entry\n      if next(current) ~= nil then\n        -- Finalize previous entry\n        table.insert(worktrees, M._finalize_worktree(current, cwd))\n      end\n      current = { path = line:match(\"^worktree (.+)\") }\n    elseif line:match(\"^HEAD \") then\n      current.head = line:match(\"^HEAD (%x+)\")\n    elseif line:match(\"^branch \") then\n      local branch_ref = line:match(\"^branch (.+)\")\n      -- Extract branch name from refs/heads/branch-name\n      current.branch = branch_ref:match(\"refs/heads/(.+)\") or branch_ref\n    elseif line:match(\"^detached\") then\n      current.is_detached = true\n    elseif line:match(\"^bare\") then\n      current.is_bare = true\n    elseif line:match(\"^locked\") then\n      current.is_locked = true\n    elseif line:match(\"^prunable\") then\n      current.is_prunable = true\n    end\n  end\n\n  -- Finalize last entry\n  if next(current) ~= nil then\n    table.insert(worktrees, M._finalize_worktree(current, cwd))\n  end\n\n  return worktrees\nend\n\n---Finalize a worktree entry by setting default fields\n---@param wt table Partial worktree data\n---@param cwd string Current working directory\n---@return Worktree\nfunction M._finalize_worktree(wt, cwd)\n  -- Resolve paths to handle symlinks\n  local wt_path = vim.fn.resolve(wt.path)\n  local resolved_cwd = vim.fn.resolve(cwd)\n\n  return {\n    path = wt.path,\n    head = wt.head or \"\",\n    branch = wt.branch,\n    is_bare = wt.is_bare or false,\n    is_current = wt_path == resolved_cwd,\n    is_locked = wt.is_locked or false,\n    is_prunable = wt.is_prunable or false,\n    is_detached = wt.is_detached or false,\n  }\nend\n\n---List all worktrees in the current repository\n---@return Worktree[]?, string? worktrees, error\nfunction M.list()\n  local stdout, err = git.worktree_list()\n  if err then\n    return nil, err\n  end\n\n  local worktrees = M.parse(stdout)\n  return worktrees, nil\nend\n\n---Create a new worktree\n---@param opts CreateWorktreeOpts Options for creating the worktree\n---@param callback? fun(worktree: Worktree?, error: string?) Async callback\n---@return Worktree?, string? worktree, error (only in sync mode when no callback)\nfunction M.create(opts, callback)\n  -- Validate required fields\n  if not opts or not opts.branch then\n    local err = \"branch is required\"\n    if callback then\n      callback(nil, err)\n      return\n    end\n    return nil, err\n  end\n\n  -- Determine path (prompt if not provided)\n  if not opts.path then\n    local git_root, root_err = git.get_git_root()\n    if root_err then\n      if callback then\n        callback(nil, root_err)\n        return\n      end\n      return nil, root_err\n    end\n\n    local default_path = vim.fn.fnamemodify(git_root, \":h\") .. \"/\" .. opts.branch\n\n    vim.ui.input({\n      prompt = \"Worktree path: \",\n      default = default_path,\n    }, function(input_path)\n      if not input_path or input_path == \"\" then\n        if callback then\n          callback(nil, \"path is required\")\n        end\n        return\n      end\n\n      -- Continue with the provided path\n      local new_opts = vim.tbl_extend(\"force\", opts, { path = input_path })\n      M._create_worktree(new_opts, callback)\n    end)\n\n    -- Async mode - callback will be called\n    if callback then\n      return\n    end\n\n    -- Sync mode not supported when prompting\n    return nil, \"path must be provided in synchronous mode\"\n  end\n\n  -- Path provided - create directly\n  return M._create_worktree(opts, callback)\nend\n\n---Internal function to create worktree after path is determined\n---@param opts CreateWorktreeOpts\n---@param callback? fun(worktree: Worktree?, error: string?)\n---@return Worktree?, string?\nfunction M._create_worktree(opts, callback)\n  local config = require(\"git-worktree.config\")\n\n  -- Create the worktree\n  local success, err = git.worktree_add(opts.path, opts.branch, {\n    create_branch = opts.create_branch or false,\n  })\n\n  if not success then\n    if callback then\n      callback(nil, err)\n      return\n    end\n    return nil, err\n  end\n\n  -- Get the created worktree object\n  local worktrees, list_err = M.list()\n  if list_err then\n    if callback then\n      callback(nil, list_err)\n      return\n    end\n    return nil, list_err\n  end\n\n  -- Find the newly created worktree (resolve paths to handle symlinks)\n  local resolved_path = vim.fn.resolve(opts.path)\n  local created_worktree = nil\n  for _, wt in ipairs(worktrees) do\n    if vim.fn.resolve(wt.path) == resolved_path then\n      created_worktree = wt\n      break\n    end\n  end\n\n  if not created_worktree then\n    local not_found_err = \"Failed to find created worktree\"\n    if callback then\n      callback(nil, not_found_err)\n      return\n    end\n    return nil, not_found_err\n  end\n\n  -- Call on_create hook if configured\n  if config.options.hooks and config.options.hooks.on_create then\n    config.options.hooks.on_create(created_worktree)\n  end\n\n  -- Switch to new worktree if requested (default: true)\n  if opts.switch ~= false then\n    -- Try to get switch function (may not exist yet in early development)\n    local ok, main = pcall(require, \"git-worktree\")\n    if ok and main.switch then\n      local switch_success, switch_err = main.switch(created_worktree.path)\n      if not switch_success then\n        -- Still return the created worktree, but note the switch error\n        vim.notify(\"Worktree created but failed to switch: \" .. (switch_err or \"unknown error\"), vim.log.levels.WARN)\n      end\n    end\n  end\n\n  if callback then\n    callback(created_worktree, nil)\n    return\n  end\n  return created_worktree, nil\nend\n\n---Switch to a different worktree\n---@param path string Path to the target worktree\n---@return boolean, string? success, error\nfunction M.switch(path)\n  local config = require(\"git-worktree.config\")\n  local buffer = require(\"git-worktree.buffer\")\n\n  -- Validate that path is a valid worktree\n  local worktrees, list_err = M.list()\n  if list_err then\n    return false, list_err\n  end\n\n  -- Resolve target path to handle symlinks\n  local resolved_target = vim.fn.resolve(path)\n\n  local target_worktree = nil\n  local current_worktree = nil\n\n  for _, wt in ipairs(worktrees) do\n    local resolved_wt_path = vim.fn.resolve(wt.path)\n    if resolved_wt_path == resolved_target then\n      target_worktree = wt\n    end\n    if wt.is_current then\n      current_worktree = wt\n    end\n  end\n\n  if not target_worktree then\n    return false, \"Path is not a valid worktree: \" .. path\n  end\n\n  -- Already in target worktree\n  if target_worktree.is_current then\n    return true, nil\n  end\n\n  -- Save current worktree reference for hook\n  if not current_worktree then\n    return false, \"Could not determine current worktree\"\n  end\n\n  -- Auto-save all modified buffers\n  buffer.save_all()\n\n  -- Change directory to target worktree\n  local ok, chdir_err = pcall(vim.fn.chdir, target_worktree.path)\n  if not ok then\n    return false, \"Failed to change directory: \" .. tostring(chdir_err)\n  end\n\n  -- Repoint buffers to new worktree paths\n  buffer.repoint(current_worktree.path, target_worktree.path)\n\n  -- Restart LSP clients\n  -- Get all active LSP clients\n  local clients = vim.lsp.get_clients()\n  for _, client in ipairs(clients) do\n    -- Stop each client\n    client.stop()\n  end\n\n  -- LSP clients will auto-restart when buffers are accessed\n\n  -- Emit autocmd event\n  vim.api.nvim_exec_autocmds(\"User\", {\n    pattern = \"GitWorktreeSwitched\",\n    data = {\n      old = current_worktree,\n      new = target_worktree,\n    },\n  })\n\n  -- Call on_switch hook\n  if config.options.hooks and config.options.hooks.on_switch then\n    config.options.hooks.on_switch(current_worktree, target_worktree)\n  end\n\n  return true, nil\nend\n\n---Delete a worktree\n---@param path string Path to the worktree to delete\n---@param opts? DeleteWorktreeOpts Options\n---@return boolean?, string? success, error\nfunction M.delete(path, opts)\n  local config = require(\"git-worktree.config\")\n\n  opts = opts or {}\n\n  -- Get all worktrees to validate\n  local worktrees, list_err = M.list()\n  if list_err then\n    return nil, list_err\n  end\n\n  -- Resolve target path to handle symlinks\n  local resolved_target = vim.fn.resolve(path)\n\n  local target_worktree = nil\n\n  for _, wt in ipairs(worktrees) do\n    local resolved_wt_path = vim.fn.resolve(wt.path)\n    if resolved_wt_path == resolved_target then\n      target_worktree = wt\n      break\n    end\n  end\n\n  if not target_worktree then\n    return nil, \"Path is not a valid worktree: \" .. path\n  end\n\n  -- Prevent deleting current worktree\n  if target_worktree.is_current then\n    return nil, \"Cannot delete current worktree. Switch to another worktree first.\"\n  end\n\n  -- Prevent deleting main worktree (bare repo)\n  if target_worktree.is_bare then\n    return nil, \"Cannot delete main (bare) worktree\"\n  end\n\n  -- Remove the worktree\n  local success, err = git.worktree_remove(path, {\n    force = opts.force or false,\n  })\n\n  if not success then\n    return nil, err\n  end\n\n  -- Call on_delete hook if configured\n  if config.options.hooks and config.options.hooks.on_delete then\n    config.options.hooks.on_delete(target_worktree)\n  end\n\n  return true, nil\nend\n\nreturn M\n","additions":0,"deletions":2},"truncated":false},"time":{"start":1768574061855,"end":1768574062378}}}}
{"type":"step_finish","timestamp":1768574062416,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73a8f2c001llXMIXyFFDg7zB","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a7651001CNlmqW2G9q26AV","type":"step-finish","reason":"tool-calls","snapshot":"0a9a7b756de5381f9c0ea0cc77d2a9c719d7258c","cost":0,"tokens":{"input":0,"output":242,"reasoning":0,"cache":{"read":15294,"write":4349}}}}
{"type":"step_start","timestamp":1768574065092,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73a99c30016fJpAp75YYdOsz","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a8f6700128FP4KKbQEmmlU","type":"step-start","snapshot":"538a603a2ced03eafdb8a6399961862f46acdd9c"}}
{"type":"text","timestamp":1768574065292,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73a99c4001EtJq0aNedzrgPX","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a8f6700128FP4KKbQEmmlU","type":"text","text":"Now let me verify CI is green:","time":{"start":1768574065290,"end":1768574065290}}}
{"type":"tool_use","timestamp":1768574067988,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73a9a8c001sw3Al6uDsB6Gri","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a8f6700128FP4KKbQEmmlU","type":"tool","callID":"toolu_01PPZCQFojf7Ad5PbBdmYqns","tool":"bash","state":{"status":"completed","input":{"command":"nix develop --command sh -c 'selene lua/ && stylua --check lua/'","description":"Verify CI passes (selene + stylua)","timeout":60000},"output":"git-worktree.nvim dev shell\n\nAvailable tools:\n  lua       - Lua 5.1 interpreter\n  luajit    - LuaJIT interpreter\n  luarocks  - Lua package manager\n  lua-language-server - LSP\n  stylua    - Lua formatter\n  selene    - Lua linter\n\nResults:\n0 errors\n0 warnings\n0 parse errors\n","title":"Verify CI passes (selene + stylua)","metadata":{"output":"git-worktree.nvim dev shell\n\nAvailable tools:\n  lua       - Lua 5.1 interpreter\n  luajit    - LuaJIT interpreter\n  luarocks  - Lua package manager\n  lua-language-server - LSP\n  stylua    - Lua formatter\n  selene    - Lua linter\n\nResults:\n0 errors\n0 warnings\n0 parse errors\n","exit":0,"description":"Verify CI passes (selene + stylua)","truncated":false},"time":{"start":1768574066809,"end":1768574067987}}}}
{"type":"step_finish","timestamp":1768574068007,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73aa514001wRLfdfFWIZDNP8","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73a8f6700128FP4KKbQEmmlU","type":"step-finish","reason":"tool-calls","snapshot":"a1aeab7fc7edda88a08f5430735ca036d388d995","cost":0,"tokens":{"input":0,"output":127,"reasoning":0,"cache":{"read":19643,"write":257}}}}
{"type":"step_start","timestamp":1768574070745,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73aafd8001RQvvCLmeTd8O64","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73aa543001CC7wQfqn0Wt7v1","type":"step-start","snapshot":"0726a4b571dac02164f0b2070da8405c501e6ffe"}}
{"type":"text","timestamp":1768574071769,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73aafd9001OFUyWDXs8ogcLU","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73aa543001CC7wQfqn0Wt7v1","type":"text","text":"CI is green. \n\nTASK_COMPLETE: Removed unused variable `config` in M.create() (line 85) to fix selene warning","time":{"start":1768574071766,"end":1768574071766}}}
{"type":"step_finish","timestamp":1768574071880,"sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","part":{"id":"prt_bc73ab427001A75cY81RPcNRcC","sessionID":"ses_438c59a28ffeOeh738gwOCjyoz","messageID":"msg_bc73aa543001CC7wQfqn0Wt7v1","type":"step-finish","reason":"stop","snapshot":"d64b6ea9f33655a075493cc94a0e781b072c565d","cost":0,"tokens":{"input":0,"output":37,"reasoning":0,"cache":{"read":19900,"write":236}}}}
